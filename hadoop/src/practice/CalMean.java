//CalMean.java
package practice;

import java.util.StringTokenizer;
import java.io.IOException;

//class IntWritable represents an integer
import org.apache.hadoop.io.IntWritable;
//class Text represents a string
import org.apache.hadoop.io.Text;

//class Mapper maps the input into the output
import org.apache.hadoop.mapreduce.Mapper;
//class Reducer is the Reduce
import org.apache.hadoop.mapreduce.Reducer;

//Path class keep the path of the files or directory
import org.apache.hadoop.fs.Path;
//bring a job for the task, the job is responsible for the configuration
import org.apache.hadoop.mapreduce.Job;
//split the file
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
//write the output file
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
//parser the hadoop command parameters
import org.apache.hadoop.util.GenericOptionsParser;

// JobConf extends Configuration
// a map/reduce job configuratjion
import org.apache.hadoop.mapred.JobConf;
//the configuration
import org.apache.hadoop.conf.Configuration;
//ToolRunner can be used to run classes implementing Tool interface
//It works in conjunction with GenericOptionsParser to parse the generic hadoop command line arguments
//and modifies the Configuration fo the Tool
import org.apache.hadoop.util.ToolRunner;

import org.apache.hadoop.util.ArrayList;
//

public class CalMean extends Configured implements Tool {
    //Mapper<K1, V1, K2, V2>
    public static class MeanMapper extends MapReduceBase implements Mapper<Object, Text, IntWritable, IntWritable> {
        //define the output key
        private IntWritable key = new IntWritable();
        //define the output value
        private IntWritable val = new IntWritable();

        String delims = ",";
        //map(K1 key, V1 value, OutputCollector<K2, V2> output, Reporter reporter);
        //Each invocation of the map() method is given a key/value pair of types K1 and V1, respectively;
        //The key/value pairs generated by the mapper are outputted via the collect() method of the OutputCollector object
        public void map(Object key, Text value, OutputCollector<IntWritable, IntWritable> output, Rexporter reporter) throws IOException {
            String line = value.toString();
            StringTokenizer st = new StringTokenizer(line, delims);

            while(st.hasMoreTokens()){
                key.set(st.nextToken());
                output.collect(key, val);
            }

        }
    }

    public static class MeanReducer extends MapReduceBase implements Reducer<IntWritable, IntWritable, IntWritable, IntWritable> {
        int count = 0;
        //each invocation of the reduce() method at the reducer is given a key of type K2 and a list of values of type V2
        //The reduce() method is also given an OutputCollector to gather its key/value output, which is of type K3/V3
        public void reduce(IntWritable key, Iterator<IntWritable> values, OutputCollector<IntWritable, IntWritable> output, Reporter reporter) throws IOException {
            int sum = 0;
            while(values.hasNext()){
                sum += values.next().get();
                count += 1;
            }

            sum = sum / count;
            // in the reduce() method we can call output.collect((K3) k, (V3) v)
            output.collect(key, new IntWritable(sum));
        }
        
    }

    public int run(String[] args) throws Exception {
        // create a new JobConf
        JobConf conf = new JobConf(new Configuration(), CalMean.class);
        //
        conf.setJobName("CalMean");

        //setup the type of key and value
        conf.setOutputKeyClass(IntWritable.class);
        conf.setOutputValueClass(IntWritable.class);

        //set the number of reduce tasks
        conf.setNumReduceTasks(2);
        
        //setup Mapper and Reducer
        conf.setMapperClass(MeanMapper.class);
        conf.setCombinerClass(MeanReducer.class);
        conf.setReducerClass(MeanReducer.class);

        /*
        List<String> other_args = new ArrayList<String>();
        for (int i=0; i<args.length; ++i){
            other_args.add(args[i]);
        }
        */

        conf.setInputFormat(TextInputFormat.class);
        conf.setOutputFormat(TextOutputFormat.class);
        
        FileInputFormat.setInputPaths(conf, new Path(args[0]));
        FileOutputFormat.setOutputPath(conf, new Path(args[1]));

        JobClient.runJob(conf);
        
        return 0;
    }

    public static void main(String[] args) throws Exception {
        int res = ToolRunner.run(new Configuration(), new CalMean(),args);
        System.exit(res);
    }
    
}
